<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_23) on Fri Apr 22 18:51:06 MSD 2011 -->
<TITLE>
Storage
</TITLE>

<META NAME="date" CONTENT="2011-04-22">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Storage";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/garret/perst/SqlOptimizerParameters.html" title="class in org.garret.perst"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/garret/perst/StorageError.html" title="class in org.garret.perst"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/garret/perst/Storage.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Storage.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.garret.perst</FONT>
<BR>
Interface Storage</H2>
<DL>
<DT><B>All Known Subinterfaces:</B> <DD><A HREF="../../../org/garret/perst/ReplicationMasterStorage.html" title="interface in org.garret.perst">ReplicationMasterStorage</A>, <A HREF="../../../org/garret/perst/ReplicationSlaveStorage.html" title="interface in org.garret.perst">ReplicationSlaveStorage</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Storage</B></DL>
</PRE>

<P>
Object storage
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE">CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Do not store information about class loaders when serialising objects with custime class loaders</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#COOPERATIVE_TRANSACTION">COOPERATIVE_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cooperative mode; all threads share the same transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#DEFAULT_PAGE_POOL_SIZE">DEFAULT_PAGE_POOL_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant specifying default pool size</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#EXCLUSIVE_TRANSACTION">EXCLUSIVE_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exclusive per-thread transaction: each thread access database in exclusive mode</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#IBM_JAVA5_COMPATIBILITY_MODE">IBM_JAVA5_COMPATIBILITY_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility with databases created by Perst prior to 2.73 release by IBM Java5 VM</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#INFINITE_PAGE_POOL">INFINITE_PAGE_POOL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant specifying that page pool should be dynamically extended 
 to conatins all database file pages</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#READ_ONLY_TRANSACTION">READ_ONLY_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alias for COOPERATIVE_TRANSACTION.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#READ_WRITE_TRANSACTION">READ_WRITE_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alias for EXCLUSIVE_TRANSACTION.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#REPLICATION_SLAVE_TRANSACTION">REPLICATION_SLAVE_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read only transaction which can be started at replicastion slave node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#SERIALIZABLE_TRANSACTION">SERIALIZABLE_TRANSACTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serializable per-thread transaction.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#backup(java.io.OutputStream)">backup</A></B>(java.io.OutputStream&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backup current state of database</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#backup(java.lang.String, java.lang.String)">backup</A></B>(java.lang.String&nbsp;filePath,
       java.lang.String&nbsp;cipherKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backup current state of database to the file with specified path</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#beginSerializableTransaction()">beginSerializableTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start serializable transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#beginThreadTransaction(int)">beginThreadTransaction</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Begin per-thread transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#clearObjectCache()">clearObjectCache</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear database object cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit transaction (if needed) and close the storage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#commit()">commit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit changes done by the last transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#commitSerializableTransaction()">commitSerializableTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit serializable transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createBag()">createBag</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new peristent multisetset (allowing several occurrences of the same object).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/BitIndex.html" title="interface in org.garret.perst">BitIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createBitIndex()">createBitIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new bit index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/CustomAllocator.html" title="interface in org.garret.perst">CustomAllocator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createBitmapAllocator(int, long, long, long)">createBitmapAllocator</A></B>(int&nbsp;quantum,
                      long&nbsp;base,
                      long&nbsp;extension,
                      long&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create bitmap custom allocator</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/Blob.html" title="interface in org.garret.perst">Blob</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createBlob()">createBlob</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new BLOB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFieldIndex(java.lang.Class, java.lang.String[], boolean)">createFieldIndex</A></B>(java.lang.Class&nbsp;type,
                 java.lang.String[]&nbsp;fieldNames,
                 boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new mutlifield index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFieldIndex(java.lang.Class, java.lang.String[], boolean, boolean)">createFieldIndex</A></B>(java.lang.Class&nbsp;type,
                 java.lang.String[]&nbsp;fieldNames,
                 boolean&nbsp;unique,
                 boolean&nbsp;caseInsensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new mutlifield index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFieldIndex(java.lang.Class, java.lang.String, boolean)">createFieldIndex</A></B>(java.lang.Class&nbsp;type,
                 java.lang.String&nbsp;fieldName,
                 boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new field index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFieldIndex(java.lang.Class, java.lang.String, boolean, boolean)">createFieldIndex</A></B>(java.lang.Class&nbsp;type,
                 java.lang.String&nbsp;fieldName,
                 boolean&nbsp;unique,
                 boolean&nbsp;caseInsensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new field index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFieldIndex(java.lang.Class, java.lang.String, boolean, boolean, boolean)">createFieldIndex</A></B>(java.lang.Class&nbsp;type,
                 java.lang.String&nbsp;fieldName,
                 boolean&nbsp;unique,
                 boolean&nbsp;caseInsensitive,
                 boolean&nbsp;thick)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new field index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/fulltext/FullTextIndex.html" title="interface in org.garret.perst.fulltext">FullTextIndex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFullTextIndex()">createFullTextIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create full text search index with default helper</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/fulltext/FullTextIndex.html" title="interface in org.garret.perst.fulltext">FullTextIndex</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createFullTextIndex(org.garret.perst.fulltext.FullTextSearchHelper)">createFullTextIndex</A></B>(<A HREF="../../../org/garret/perst/fulltext/FullTextSearchHelper.html" title="class in org.garret.perst.fulltext">FullTextSearchHelper</A>&nbsp;helper)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create full text search index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/garret/perst/IPersistentHash.html" title="interface in org.garret.perst">IPersistentHash</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createHash()">createHash</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create hierarhical hash table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/garret/perst/IPersistentHash.html" title="interface in org.garret.perst">IPersistentHash</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createHash(int, int)">createHash</A></B>(int&nbsp;pageSize,
           int&nbsp;loadFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create hierarhical hash table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createIndex(java.lang.Class[], boolean)">createIndex</A></B>(java.lang.Class[]&nbsp;types,
            boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new compound index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createIndex(java.lang.Class, boolean)">createIndex</A></B>(java.lang.Class&nbsp;type,
            boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Link.html" title="interface in org.garret.perst">Link</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createLink()">createLink</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create one-to-many link.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Link.html" title="interface in org.garret.perst">Link</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createLink(int)">createLink</A></B>(int&nbsp;initialSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create one-to-many link with specified initialy alloced size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createList()">createList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new peristent list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K extends java.lang.Comparable,V&gt; 
<BR>
<A HREF="../../../org/garret/perst/IPersistentMap.html" title="interface in org.garret.perst">IPersistentMap</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createMap(java.lang.Class)">createMap</A></B>(java.lang.Class&nbsp;keyType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create scalable persistent map.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K extends java.lang.Comparable,V&gt; 
<BR>
<A HREF="../../../org/garret/perst/IPersistentMap.html" title="interface in org.garret.perst">IPersistentMap</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createMap(java.lang.Class, int)">createMap</A></B>(java.lang.Class&nbsp;keyType,
          int&nbsp;initialSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create scalable persistent map.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/MultidimensionalIndex.html" title="interface in org.garret.perst">MultidimensionalIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createMultidimensionalIndex(java.lang.Class, java.lang.String[], boolean)">createMultidimensionalIndex</A></B>(java.lang.Class&nbsp;type,
                            java.lang.String[]&nbsp;fieldNames,
                            boolean&nbsp;treateZeroAsUndefinedValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new multidimensional index for specified fields of the class</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/MultidimensionalIndex.html" title="interface in org.garret.perst">MultidimensionalIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createMultidimensionalIndex(org.garret.perst.MultidimensionalComparator)">createMultidimensionalIndex</A></B>(<A HREF="../../../org/garret/perst/MultidimensionalComparator.html" title="class in org.garret.perst">MultidimensionalComparator</A>&lt;T&gt;&nbsp;comparator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new multidimensional index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/PatriciaTrie.html" title="interface in org.garret.perst">PatriciaTrie</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createPatriciaTrie()">createPatriciaTrie</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
 Tries are a kind of tree where each node holds a common part of one or more keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Query.html" title="interface in org.garret.perst">Query</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createQuery()">createQuery</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create JSQL query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/Blob.html" title="interface in org.garret.perst">Blob</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessBlob()">createRandomAccessBlob</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new random access BLOB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessFieldIndex(java.lang.Class, java.lang.String[], boolean)">createRandomAccessFieldIndex</A></B>(java.lang.Class&nbsp;type,
                             java.lang.String[]&nbsp;fieldNames,
                             boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new mutlifield index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessFieldIndex(java.lang.Class, java.lang.String[], boolean, boolean)">createRandomAccessFieldIndex</A></B>(java.lang.Class&nbsp;type,
                             java.lang.String[]&nbsp;fieldNames,
                             boolean&nbsp;unique,
                             boolean&nbsp;caseInsensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new mutlifield index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessFieldIndex(java.lang.Class, java.lang.String, boolean)">createRandomAccessFieldIndex</A></B>(java.lang.Class&nbsp;type,
                             java.lang.String&nbsp;fieldName,
                             boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new field index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessFieldIndex(java.lang.Class, java.lang.String, boolean, boolean)">createRandomAccessFieldIndex</A></B>(java.lang.Class&nbsp;type,
                             java.lang.String&nbsp;fieldName,
                             boolean&nbsp;unique,
                             boolean&nbsp;caseInsensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new field index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessIndex(java.lang.Class[], boolean)">createRandomAccessIndex</A></B>(java.lang.Class[]&nbsp;types,
                        boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new compound index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRandomAccessIndex(java.lang.Class, boolean)">createRandomAccessIndex</A></B>(java.lang.Class&nbsp;type,
                        boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new index optimized for access by element position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;M,O&gt; <A HREF="../../../org/garret/perst/Relation.html" title="class in org.garret.perst">Relation</A>&lt;M,O&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createRelation(O)">createRelation</A></B>(O&nbsp;owner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create relation object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createScalableList()">createScalableList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new scalable list of persistent objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createScalableList(int)">createScalableList</A></B>(int&nbsp;initialSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new scalable list of persistent objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createScalableSet()">createScalableSet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new scalable set references to persistent objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createScalableSet(int)">createScalableSet</A></B>(int&nbsp;initialSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new scalable set references to persistent objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createSet()">createSet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new peristent set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/SortedCollection.html" title="interface in org.garret.perst">SortedCollection</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createSortedCollection(org.garret.perst.PersistentComparator, boolean)">createSortedCollection</A></B>(<A HREF="../../../org/garret/perst/PersistentComparator.html" title="class in org.garret.perst">PersistentComparator</A>&lt;T&gt;&nbsp;comparator,
                       boolean&nbsp;unique)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new sorted collection</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/SpatialIndex.html" title="interface in org.garret.perst">SpatialIndex</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createSpatialIndex()">createSpatialIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new spatial index with integer coordinates</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/SpatialIndexR2.html" title="interface in org.garret.perst">SpatialIndexR2</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createSpatialIndexR2()">createSpatialIndexR2</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new R2 spatial index</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createThickIndex(java.lang.Class)">createThickIndex</A></B>(java.lang.Class&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new think index (index with large number of duplicated keys)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/garret/perst/TimeSeries.Tick.html" title="interface in org.garret.perst">TimeSeries.Tick</A>&gt; 
<BR>
<A HREF="../../../org/garret/perst/TimeSeries.html" title="interface in org.garret.perst">TimeSeries</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#createTimeSeries(java.lang.Class, long)">createTimeSeries</A></B>(java.lang.Class&nbsp;blockClass,
                 long&nbsp;maxBlockTimeInterval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new time series object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#deallocate(java.lang.Object)">deallocate</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deallocaste object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#deallocateObject(java.lang.Object)">deallocateObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#endThreadTransaction()">endThreadTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End per-thread transaction started by beginThreadTransaction method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#endThreadTransaction(int)">endThreadTransaction</A></B>(int&nbsp;maxDelay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End per-thread cooperative transaction with specified maximal delay of transaction
 commit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#exportXML(java.io.Writer)">exportXML</A></B>(java.io.Writer&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Export database in XML format</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.ClassLoader</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#findClassLoader(java.lang.String)">findClassLoader</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find registered class loaders by name</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#gc()">gc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit start of garbage collector</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.ClassLoader</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getClassLoader()">getClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get class loader used to locate classes for 
 loaded class descriptors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getDatabaseFormatVersion()">getDatabaseFormatVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get version of database format for this database.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getDatabaseSize()">getDatabaseSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get size of the database</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getListener()">getListener</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get storage listener.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap&lt;java.lang.Class,<A HREF="../../../org/garret/perst/MemoryUsage.html" title="class in org.garret.perst">MemoryUsage</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getMemoryDump()">getMemoryDump</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get database memory dump.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getObjectByOID(int)">getObjectByOID</A></B>(int&nbsp;oid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve object by OID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getOid(java.lang.Object)">getOid</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get object identifier</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Properties</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getProperties()">getProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all set properties</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getProperty(java.lang.String)">getProperty</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get property value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getRoot()">getRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get storage root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/SqlOptimizerParameters.html" title="class in org.garret.perst">SqlOptimizerParameters</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getSqlOptimizerParameters()">getSqlOptimizerParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get SQL optimizer parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.garret.perst.impl.ThreadTransactionContext</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getTransactionContext()">getTransactionContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used internally by Perst to get transaction context associated with current thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#getUsedSize()">getUsedSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get total size of all allocated objects in the database</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#importXML(java.io.Reader)">importXML</A></B>(java.io.Reader&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Import data from XML file</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#isInsideThreadTransaction()">isInsideThreadTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if nested thread transaction is active</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#isOpened()">isOpened</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if database is opened</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#join(java.util.Iterator[])">join</A></B>(java.util.Iterator[]&nbsp;selections)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Join results of several index searches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#load(java.lang.Object)">load</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load raw object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#loadObject(java.lang.Object)">loadObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#lockObject(java.lang.Object)">lockObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#makePersistent(java.lang.Object)">makePersistent</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitely make object peristent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#merge(java.util.Iterator[])">merge</A></B>(java.util.Iterator[]&nbsp;selections)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge results of several index searches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#modify(java.lang.Object)">modify</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mark object as been modified</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#modifyObject(java.lang.Object)">modifyObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#open(org.garret.perst.IFile)">open</A></B>(<A HREF="../../../org/garret/perst/IFile.html" title="interface in org.garret.perst">IFile</A>&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open the storage with default page pool size</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#open(org.garret.perst.IFile, long)">open</A></B>(<A HREF="../../../org/garret/perst/IFile.html" title="interface in org.garret.perst">IFile</A>&nbsp;file,
     long&nbsp;pagePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open the storage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#open(java.lang.String)">open</A></B>(java.lang.String&nbsp;filePath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open the storage with default page pool size</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#open(java.lang.String, long)">open</A></B>(java.lang.String&nbsp;filePath,
     long&nbsp;pagePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open the storage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#open(java.lang.String, long, java.lang.String)">open</A></B>(java.lang.String&nbsp;filePath,
     long&nbsp;pagePoolSize,
     java.lang.String&nbsp;cipherKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open the encrypted storage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#registerClassLoader(org.garret.perst.INamedClassLoader)">registerClassLoader</A></B>(<A HREF="../../../org/garret/perst/INamedClassLoader.html" title="interface in org.garret.perst">INamedClassLoader</A>&nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register named class loader in the storage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#registerCustomAllocator(java.lang.Class, org.garret.perst.CustomAllocator)">registerCustomAllocator</A></B>(java.lang.Class&nbsp;cls,
                        <A HREF="../../../org/garret/perst/CustomAllocator.html" title="interface in org.garret.perst">CustomAllocator</A>&nbsp;allocator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register custom allocator for specified class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#rollback()">rollback</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rollback changes made by the last transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#rollbackSerializableTransaction()">rollbackSerializableTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rollback serializable transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#rollbackThreadTransaction()">rollbackThreadTransaction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rollback per-thread transaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.ClassLoader</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setClassLoader(java.lang.ClassLoader)">setClassLoader</A></B>(java.lang.ClassLoader&nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set class loader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setCustomSerializer(org.garret.perst.CustomSerializer)">setCustomSerializer</A></B>(<A HREF="../../../org/garret/perst/CustomSerializer.html" title="interface in org.garret.perst">CustomSerializer</A>&nbsp;serializer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set custom serializer used fot packing/unpacking fields of persistent objects which types implemplemet 
 CustomSerializable interface</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setGcThreshold(long)">setGcThreshold</A></B>(long&nbsp;allocatedDelta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set threshold for initiation of garbage collection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setListener(org.garret.perst.StorageListener)">setListener</A></B>(<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set storage listener.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setProperties(java.util.Properties)">setProperties</A></B>(java.util.Properties&nbsp;props)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set database properties.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(java.lang.String&nbsp;name,
            java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set database property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setRecursiveLoading(java.lang.Class, boolean)">setRecursiveLoading</A></B>(java.lang.Class&nbsp;type,
                    boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable or disable recursive loading for specified class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setRoot(java.lang.Object)">setRoot</A></B>(java.lang.Object&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set new storage root object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.garret.perst.impl.ThreadTransactionContext</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#setTransactionContext(org.garret.perst.impl.ThreadTransactionContext)">setTransactionContext</A></B>(org.garret.perst.impl.ThreadTransactionContext&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associate transaction context with the thread
 This method can be used by application to share the same transaction between multiple threads</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#store(java.lang.Object)">store</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store object in storage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#storeFinalizedObject(java.lang.Object)">storeFinalizedObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#storeObject(java.lang.Object)">storeObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/garret/perst/Storage.html#throwObject(java.lang.Object)">throwObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE"><!-- --></A><H3>
CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE</H3>
<PRE>
static final int <B>CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE</B></PRE>
<DL>
<DD>Do not store information about class loaders when serialising objects with custime class loaders
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COOPERATIVE_TRANSACTION"><!-- --></A><H3>
COOPERATIVE_TRANSACTION</H3>
<PRE>
static final int <B>COOPERATIVE_TRANSACTION</B></PRE>
<DL>
<DD>Cooperative mode; all threads share the same transaction. Commit will commit changes made
 by all threads. To make this schema work correctly, it is necessary to ensure (using locking)
 that no thread is performing update of the database while another one tries to perform commit.
 Also please notice that rollback will undo the work of all threads.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.COOPERATIVE_TRANSACTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEFAULT_PAGE_POOL_SIZE"><!-- --></A><H3>
DEFAULT_PAGE_POOL_SIZE</H3>
<PRE>
static final int <B>DEFAULT_PAGE_POOL_SIZE</B></PRE>
<DL>
<DD>Constant specifying default pool size
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.DEFAULT_PAGE_POOL_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="EXCLUSIVE_TRANSACTION"><!-- --></A><H3>
EXCLUSIVE_TRANSACTION</H3>
<PRE>
static final int <B>EXCLUSIVE_TRANSACTION</B></PRE>
<DL>
<DD>Exclusive per-thread transaction: each thread access database in exclusive mode
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.EXCLUSIVE_TRANSACTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="IBM_JAVA5_COMPATIBILITY_MODE"><!-- --></A><H3>
IBM_JAVA5_COMPATIBILITY_MODE</H3>
<PRE>
static final int <B>IBM_JAVA5_COMPATIBILITY_MODE</B></PRE>
<DL>
<DD>Compatibility with databases created by Perst prior to 2.73 release by IBM Java5 VM
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.IBM_JAVA5_COMPATIBILITY_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INFINITE_PAGE_POOL"><!-- --></A><H3>
INFINITE_PAGE_POOL</H3>
<PRE>
static final int <B>INFINITE_PAGE_POOL</B></PRE>
<DL>
<DD>Constant specifying that page pool should be dynamically extended 
 to conatins all database file pages
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.INFINITE_PAGE_POOL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="READ_ONLY_TRANSACTION"><!-- --></A><H3>
READ_ONLY_TRANSACTION</H3>
<PRE>
static final int <B>READ_ONLY_TRANSACTION</B></PRE>
<DL>
<DD>Alias for COOPERATIVE_TRANSACTION. In case of multiclient access, 
 only read-only transactions can be executed in parallel.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.READ_ONLY_TRANSACTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="READ_WRITE_TRANSACTION"><!-- --></A><H3>
READ_WRITE_TRANSACTION</H3>
<PRE>
static final int <B>READ_WRITE_TRANSACTION</B></PRE>
<DL>
<DD>Alias for EXCLUSIVE_TRANSACTION. In case of multiclient access, 
 any transaction modifying database should be exclusive.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.READ_WRITE_TRANSACTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="REPLICATION_SLAVE_TRANSACTION"><!-- --></A><H3>
REPLICATION_SLAVE_TRANSACTION</H3>
<PRE>
static final int <B>REPLICATION_SLAVE_TRANSACTION</B></PRE>
<DL>
<DD>Read only transaction which can be started at replicastion slave node.
 It runs concurrently with receiving updates from master node.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.REPLICATION_SLAVE_TRANSACTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SERIALIZABLE_TRANSACTION"><!-- --></A><H3>
SERIALIZABLE_TRANSACTION</H3>
<PRE>
static final int <B>SERIALIZABLE_TRANSACTION</B></PRE>
<DL>
<DD>Serializable per-thread transaction. Unlike exclusive mode, threads can concurrently access database, 
 but effect will be the same as them work exclusively.
 To provide such behavior, programmer should lock all access objects (or use hierarchical locking).
 When object is updated, exclusive lock should be set, otherwise shared lock is enough.
 Lock should be preserved until the end of transaction.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.garret.perst.Storage.SERIALIZABLE_TRANSACTION">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="backup(java.io.OutputStream)"><!-- --></A><H3>
backup</H3>
<PRE>
void <B>backup</B>(java.io.OutputStream&nbsp;out)
            throws java.io.IOException</PRE>
<DL>
<DD>Backup current state of database
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - output stream to which backup is done
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="backup(java.lang.String, java.lang.String)"><!-- --></A><H3>
backup</H3>
<PRE>
void <B>backup</B>(java.lang.String&nbsp;filePath,
            java.lang.String&nbsp;cipherKey)
            throws java.io.IOException</PRE>
<DL>
<DD>Backup current state of database to the file with specified path
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filePath</CODE> - path to the backup file<DD><CODE>cipherKey</CODE> - cipher key for the encryption oof the backup file, null to disable encryption
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="beginSerializableTransaction()"><!-- --></A><H3>
beginSerializableTransaction</H3>
<PRE>
void <B>beginSerializableTransaction</B>()</PRE>
<DL>
<DD>Start serializable transaction.
 This call is equivalent to <code>beginThreadTransaction(Storage.SERIALIZABLE_TRANSACTION)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="beginThreadTransaction(int)"><!-- --></A><H3>
beginThreadTransaction</H3>
<PRE>
void <B>beginThreadTransaction</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Begin per-thread transaction. Three types of per-thread transactions are supported: 
 exclusive, cooperative and serializable. In case of exclusive transaction, only one 
 thread can update the database. In cooperative mode, multiple transaction can work 
 concurrently and commit() method will be invoked only when transactions of all threads
 are terminated. Serializable transactions can also work concurrently. But unlike
 cooperative transaction, the threads are isolated from each other. Each thread
 has its own associated set of modified objects and committing the transaction will cause
 saving only of these objects to the database. To synchronize access to the objects
 in case of serializable transaction programmer should use lock methods
 of IResource interface. Shared lock should be set before read access to any object, 
 and exclusive lock - before write access. Locks will be automatically released when
 transaction is committed (so programmer should not explicitly invoke unlock method)
 In this case it is guaranteed that transactions are serializable.<br>
 It is not possible to use <code>IPersistent.store()</code> method in
 serializable transactions. That is why it is also not possible to use Index and FieldIndex
 containers (since them are based on B-Tree and B-Tree directly access database pages
 and use <code>store()</code> method to assign OID to inserted object. 
 You should use <code>SortedCollection</code> based on T-Tree instead or alternative
 B-Tree implemenataion (set "perst.alternative.btree" property).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - <code>EXCLUSIVE_TRANSACTION</code>, <code>COOPERATIVE_TRANSACTION</code>, 
 <code>SERIALIZABLE_TRANSACTION</code> or <code>REPLICATION_SLAVE_TRANSACTION</code></DL>
</DD>
</DL>
<HR>

<A NAME="clearObjectCache()"><!-- --></A><H3>
clearObjectCache</H3>
<PRE>
void <B>clearObjectCache</B>()</PRE>
<DL>
<DD>Clear database object cache. This method can be used with "strong" object cache to avoid memory overflow.
 It is no valid to invoke this method when there are some uncommitted changes in the database
 (some modified objects). Also all variables containing references to persistent object should be reset after
 invocation of this method - it is not correct to accessed object directly though such variables, objects
 has to be reloaded from the storage
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
void <B>close</B>()</PRE>
<DL>
<DD>Commit transaction (if needed) and close the storage
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="commit()"><!-- --></A><H3>
commit</H3>
<PRE>
void <B>commit</B>()</PRE>
<DL>
<DD>Commit changes done by the last transaction. Transaction is started implcitlely with forst update
 opertation.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="commitSerializableTransaction()"><!-- --></A><H3>
commitSerializableTransaction</H3>
<PRE>
void <B>commitSerializableTransaction</B>()</PRE>
<DL>
<DD>Commit serializable transaction. This call is equivalent to <code>endThreadTransaction</code>
 but it checks that serializable transaction was pereviously started using 
 beginSerializableTransaction() method
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>StorageError(NOT_IN_TRANSACTION)</CODE> - if this method is invoked outside 
 serializable transaction body</DL>
</DD>
</DL>
<HR>

<A NAME="createBag()"><!-- --></A><H3>
createBag</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt; <B>createBag</B>()</PRE>
<DL>
<DD>Create new peristent multisetset (allowing several occurrences of the same object). 
 Implementation of this set is based on B-Tree so it can efficiently
 handle large number of objects but in case of very small set memory overhead is too high.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing set</DL>
</DD>
</DL>
<HR>

<A NAME="createBitIndex()"><!-- --></A><H3>
createBitIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/BitIndex.html" title="interface in org.garret.perst">BitIndex</A>&lt;T&gt; <B>createBitIndex</B>()</PRE>
<DL>
<DD>Create new bit index. Bit index is used to select object 
 with specified set of (boolean) properties.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing bit index</DL>
</DD>
</DL>
<HR>

<A NAME="createBitmapAllocator(int, long, long, long)"><!-- --></A><H3>
createBitmapAllocator</H3>
<PRE>
<A HREF="../../../org/garret/perst/CustomAllocator.html" title="interface in org.garret.perst">CustomAllocator</A> <B>createBitmapAllocator</B>(int&nbsp;quantum,
                                      long&nbsp;base,
                                      long&nbsp;extension,
                                      long&nbsp;limit)</PRE>
<DL>
<DD>Create bitmap custom allocator
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>quantum</CODE> - size in bytes of allocation quantum. Should be power of two.<DD><CODE>base</CODE> - base address for allocator (it should match offset of multifile segment)<DD><CODE>extension</CODE> - size by which space mapped by allocator is extended each time when 
 no suitable hole is found in bitmap (it should be large enough to improve allocation speed and locality 
 of references)<DD><CODE>limit</CODE> - maximal size of memory allocated by this allocator (pass Long.MAX_VALUE if you do not 
 want to limit space)
<DT><B>Returns:</B><DD>created allocator</DL>
</DD>
</DL>
<HR>

<A NAME="createBlob()"><!-- --></A><H3>
createBlob</H3>
<PRE>
<A HREF="../../../org/garret/perst/Blob.html" title="interface in org.garret.perst">Blob</A> <B>createBlob</B>()</PRE>
<DL>
<DD>Create new BLOB. Create object for storing large binary data.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>empty BLOB</DL>
</DD>
</DL>
<HR>

<A NAME="createFieldIndex(java.lang.Class, java.lang.String[], boolean)"><!-- --></A><H3>
createFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createFieldIndex</B>(java.lang.Class&nbsp;type,
                                   java.lang.String[]&nbsp;fieldNames,
                                   boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new mutlifield index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldNames</CODE> - names of the index fields. Fields with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createFieldIndex(java.lang.Class, java.lang.String[], boolean, boolean)"><!-- --></A><H3>
createFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createFieldIndex</B>(java.lang.Class&nbsp;type,
                                   java.lang.String[]&nbsp;fieldNames,
                                   boolean&nbsp;unique,
                                   boolean&nbsp;caseInsensitive)</PRE>
<DL>
<DD>Create new mutlifield index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldNames</CODE> - names of the index fields. Fields with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)<DD><CODE>caseInsensitive</CODE> - whether index is case insensitive (ignored for non-string keys)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createFieldIndex(java.lang.Class, java.lang.String, boolean)"><!-- --></A><H3>
createFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createFieldIndex</B>(java.lang.Class&nbsp;type,
                                   java.lang.String&nbsp;fieldName,
                                   boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new field index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldName</CODE> - name of the index field. Field with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createFieldIndex(java.lang.Class, java.lang.String, boolean, boolean)"><!-- --></A><H3>
createFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createFieldIndex</B>(java.lang.Class&nbsp;type,
                                   java.lang.String&nbsp;fieldName,
                                   boolean&nbsp;unique,
                                   boolean&nbsp;caseInsensitive)</PRE>
<DL>
<DD>Create new field index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldName</CODE> - name of the index field. Field with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)<DD><CODE>caseInsensitive</CODE> - if string index is case insensitive
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createFieldIndex(java.lang.Class, java.lang.String, boolean, boolean, boolean)"><!-- --></A><H3>
createFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createFieldIndex</B>(java.lang.Class&nbsp;type,
                                   java.lang.String&nbsp;fieldName,
                                   boolean&nbsp;unique,
                                   boolean&nbsp;caseInsensitive,
                                   boolean&nbsp;thick)</PRE>
<DL>
<DD>Create new field index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldName</CODE> - name of the index field. Field with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)<DD><CODE>caseInsensitive</CODE> - if string index is case insensitive<DD><CODE>thick</CODE> - index should be optimized to handle large number of duplicate key values
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createFullTextIndex()"><!-- --></A><H3>
createFullTextIndex</H3>
<PRE>
<A HREF="../../../org/garret/perst/fulltext/FullTextIndex.html" title="interface in org.garret.perst.fulltext">FullTextIndex</A> <B>createFullTextIndex</B>()</PRE>
<DL>
<DD>Create full text search index with default helper
<P>
<DD><DL>

<DT><B>Returns:</B><DD>full text search index</DL>
</DD>
</DL>
<HR>

<A NAME="createFullTextIndex(org.garret.perst.fulltext.FullTextSearchHelper)"><!-- --></A><H3>
createFullTextIndex</H3>
<PRE>
<A HREF="../../../org/garret/perst/fulltext/FullTextIndex.html" title="interface in org.garret.perst.fulltext">FullTextIndex</A> <B>createFullTextIndex</B>(<A HREF="../../../org/garret/perst/fulltext/FullTextSearchHelper.html" title="class in org.garret.perst.fulltext">FullTextSearchHelper</A>&nbsp;helper)</PRE>
<DL>
<DD>Create full text search index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>helper</CODE> - helper class which provides method for scanning, stemming and tuning query
<DT><B>Returns:</B><DD>full text search index</DL>
</DD>
</DL>
<HR>

<A NAME="createHash()"><!-- --></A><H3>
createHash</H3>
<PRE>
&lt;K,V&gt; <A HREF="../../../org/garret/perst/IPersistentHash.html" title="interface in org.garret.perst">IPersistentHash</A>&lt;K,V&gt; <B>createHash</B>()</PRE>
<DL>
<DD>Create hierarhical hash table. Levels of tree are added on demand.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent hash table</DL>
</DD>
</DL>
<HR>

<A NAME="createHash(int, int)"><!-- --></A><H3>
createHash</H3>
<PRE>
&lt;K,V&gt; <A HREF="../../../org/garret/perst/IPersistentHash.html" title="interface in org.garret.perst">IPersistentHash</A>&lt;K,V&gt; <B>createHash</B>(int&nbsp;pageSize,
                                      int&nbsp;loadFactor)</PRE>
<DL>
<DD>Create hierarhical hash table. Levels of tree are added on demand.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent hash table</DL>
</DD>
</DL>
<HR>

<A NAME="createIndex(java.lang.Class[], boolean)"><!-- --></A><H3>
createIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt; <B>createIndex</B>(java.lang.Class[]&nbsp;types,
                         boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new compound index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>types</CODE> - types of the index compound key components<DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing compound index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.UNSUPPORTED_INDEX_TYPE)</CODE> - exception if 
 specified key type is not supported by implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="createIndex(java.lang.Class, boolean)"><!-- --></A><H3>
createIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt; <B>createIndex</B>(java.lang.Class&nbsp;type,
                         boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - type of the index key (you should path here <code>String.class</code>, 
 <code>int.class</code>, ...)<DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.UNSUPPORTED_INDEX_TYPE)</CODE> - exception if 
 specified key type is not supported by implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="createLink()"><!-- --></A><H3>
createLink</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Link.html" title="interface in org.garret.perst">Link</A>&lt;T&gt; <B>createLink</B>()</PRE>
<DL>
<DD>Create one-to-many link.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>new empty link, new members can be added to the link later.</DL>
</DD>
</DL>
<HR>

<A NAME="createLink(int)"><!-- --></A><H3>
createLink</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Link.html" title="interface in org.garret.perst">Link</A>&lt;T&gt; <B>createLink</B>(int&nbsp;initialSize)</PRE>
<DL>
<DD>Create one-to-many link with specified initialy alloced size.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialSize</CODE> - initial size of array
<DT><B>Returns:</B><DD>new empty link, new members can be added to the link later.</DL>
</DD>
</DL>
<HR>

<A NAME="createList()"><!-- --></A><H3>
createList</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt; <B>createList</B>()</PRE>
<DL>
<DD>Create new peristent list. Implementation of this list is based on B-Tree so it can efficiently
 handle large number of objects but in case of very small list memory overhead is too high.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing list</DL>
</DD>
</DL>
<HR>

<A NAME="createMap(java.lang.Class)"><!-- --></A><H3>
createMap</H3>
<PRE>
&lt;K extends java.lang.Comparable,V&gt; <A HREF="../../../org/garret/perst/IPersistentMap.html" title="interface in org.garret.perst">IPersistentMap</A>&lt;K,V&gt; <B>createMap</B>(java.lang.Class&nbsp;keyType)</PRE>
<DL>
<DD>Create scalable persistent map.
 This container can efficiently handle both small and large number of members.
 For small maps, implementation  uses sorted array. For large maps - B-Tree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keyType</CODE> - map key type
<DT><B>Returns:</B><DD>scalable map implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createMap(java.lang.Class, int)"><!-- --></A><H3>
createMap</H3>
<PRE>
&lt;K extends java.lang.Comparable,V&gt; <A HREF="../../../org/garret/perst/IPersistentMap.html" title="interface in org.garret.perst">IPersistentMap</A>&lt;K,V&gt; <B>createMap</B>(java.lang.Class&nbsp;keyType,
                                                                 int&nbsp;initialSize)</PRE>
<DL>
<DD>Create scalable persistent map.
 This container can efficiently handle both small and large number of members.
 For small maps, implementation  uses sorted array. For large maps - B-Tree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keyType</CODE> - map key type<DD><CODE>initialSize</CODE> - initial allocated size of the list
<DT><B>Returns:</B><DD>scalable map implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createMultidimensionalIndex(java.lang.Class, java.lang.String[], boolean)"><!-- --></A><H3>
createMultidimensionalIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/MultidimensionalIndex.html" title="interface in org.garret.perst">MultidimensionalIndex</A>&lt;T&gt; <B>createMultidimensionalIndex</B>(java.lang.Class&nbsp;type,
                                                         java.lang.String[]&nbsp;fieldNames,
                                                         boolean&nbsp;treateZeroAsUndefinedValue)</PRE>
<DL>
<DD>Create new multidimensional index for specified fields of the class
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - class of objects included in this index<DD><CODE>fieldNames</CODE> - name of the fields which are treated as index dimensions, 
 if null then all declared fields of the class are used.<DD><CODE>treateZeroAsUndefinedValue</CODE> - if value of scalar field in QBE object is 0 (default value) then assume 
 that condition is not defined for this field
<DT><B>Returns:</B><DD>multidimensional index</DL>
</DD>
</DL>
<HR>

<A NAME="createMultidimensionalIndex(org.garret.perst.MultidimensionalComparator)"><!-- --></A><H3>
createMultidimensionalIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/MultidimensionalIndex.html" title="interface in org.garret.perst">MultidimensionalIndex</A>&lt;T&gt; <B>createMultidimensionalIndex</B>(<A HREF="../../../org/garret/perst/MultidimensionalComparator.html" title="class in org.garret.perst">MultidimensionalComparator</A>&lt;T&gt;&nbsp;comparator)</PRE>
<DL>
<DD>Create new multidimensional index
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>comparator</CODE> - multidimensinal comparator
<DT><B>Returns:</B><DD>multidimensional index</DL>
</DD>
</DL>
<HR>

<A NAME="createPatriciaTrie()"><!-- --></A><H3>
createPatriciaTrie</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/PatriciaTrie.html" title="interface in org.garret.perst">PatriciaTrie</A>&lt;T&gt; <B>createPatriciaTrie</B>()</PRE>
<DL>
<DD>Create PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
 Tries are a kind of tree where each node holds a common part of one or more keys. 
 PATRICIA trie is one of the many existing variants of the trie, which adds path compression 
 by grouping common sequences of nodes together.<BR>
 This structure provides a very efficient way of storing values while maintaining the lookup time 
 for a key in O(N) in the worst case, where N is the length of the longest key. 
 This structure has it's main use in IP routing software, but can provide an interesting alternative 
 to other structures such as hashtables when memory space is of concern.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>created PATRICIA trie</DL>
</DD>
</DL>
<HR>

<A NAME="createQuery()"><!-- --></A><H3>
createQuery</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Query.html" title="interface in org.garret.perst">Query</A>&lt;T&gt; <B>createQuery</B>()</PRE>
<DL>
<DD>Create JSQL query. JSQL is object oriented subset of SQL allowing
 to specify arbitrary prdicates for selecting members of Perst collections
<P>
<DD><DL>

<DT><B>Returns:</B><DD>created query object</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessBlob()"><!-- --></A><H3>
createRandomAccessBlob</H3>
<PRE>
<A HREF="../../../org/garret/perst/Blob.html" title="interface in org.garret.perst">Blob</A> <B>createRandomAccessBlob</B>()</PRE>
<DL>
<DD>Create new random access BLOB. Create file-like object providing efficient random poistion access.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>empty BLOB</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessFieldIndex(java.lang.Class, java.lang.String[], boolean)"><!-- --></A><H3>
createRandomAccessFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createRandomAccessFieldIndex</B>(java.lang.Class&nbsp;type,
                                               java.lang.String[]&nbsp;fieldNames,
                                               boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new mutlifield index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldNames</CODE> - names of the index fields. Fields with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessFieldIndex(java.lang.Class, java.lang.String[], boolean, boolean)"><!-- --></A><H3>
createRandomAccessFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createRandomAccessFieldIndex</B>(java.lang.Class&nbsp;type,
                                               java.lang.String[]&nbsp;fieldNames,
                                               boolean&nbsp;unique,
                                               boolean&nbsp;caseInsensitive)</PRE>
<DL>
<DD>Create new mutlifield index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldNames</CODE> - names of the index fields. Fields with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)<DD><CODE>caseInsensitive</CODE> - whether index is case insensitive (ignored for non-string keys)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessFieldIndex(java.lang.Class, java.lang.String, boolean)"><!-- --></A><H3>
createRandomAccessFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createRandomAccessFieldIndex</B>(java.lang.Class&nbsp;type,
                                               java.lang.String&nbsp;fieldName,
                                               boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new field index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldName</CODE> - name of the index field. Field with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessFieldIndex(java.lang.Class, java.lang.String, boolean, boolean)"><!-- --></A><H3>
createRandomAccessFieldIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/FieldIndex.html" title="interface in org.garret.perst">FieldIndex</A>&lt;T&gt; <B>createRandomAccessFieldIndex</B>(java.lang.Class&nbsp;type,
                                               java.lang.String&nbsp;fieldName,
                                               boolean&nbsp;unique,
                                               boolean&nbsp;caseInsensitive)</PRE>
<DL>
<DD>Create new field index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - objects of which type (or derived from which type) will be included in the index<DD><CODE>fieldName</CODE> - name of the index field. Field with such name should be present in specified class <code>type</code><DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)<DD><CODE>caseInsensitive</CODE> - whether index is case insensitive (ignored for non-string keys)
<DT><B>Returns:</B><DD>persistent object implementing field index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.INDEXED_FIELD_NOT_FOUND)</CODE> - if there is no such field in specified class,<BR> 
 StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessIndex(java.lang.Class[], boolean)"><!-- --></A><H3>
createRandomAccessIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt; <B>createRandomAccessIndex</B>(java.lang.Class[]&nbsp;types,
                                     boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new compound index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>types</CODE> - types of the index compound key components<DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing compound index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.UNSUPPORTED_INDEX_TYPE)</CODE> - exception if 
 specified key type is not supported by implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="createRandomAccessIndex(java.lang.Class, boolean)"><!-- --></A><H3>
createRandomAccessIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt; <B>createRandomAccessIndex</B>(java.lang.Class&nbsp;type,
                                     boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new index optimized for access by element position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - type of the index key (you should path here <code>String.class</code>, 
 <code>int.class</code>, ...)<DD><CODE>unique</CODE> - whether index is unique (duplicate value of keys are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.UNSUPPORTED_INDEX_TYPE)</CODE> - exception if 
 specified key type is not supported by implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="createRelation(java.lang.Object)"><!-- --></A><A NAME="createRelation(O)"><!-- --></A><H3>
createRelation</H3>
<PRE>
&lt;M,O&gt; <A HREF="../../../org/garret/perst/Relation.html" title="class in org.garret.perst">Relation</A>&lt;M,O&gt; <B>createRelation</B>(O&nbsp;owner)</PRE>
<DL>
<DD>Create relation object. Unlike link which represent embedded relation and stored
 inside owner object, this Relation object is standalone persisitent object
 containing references to owner and members of the relation
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>owner</CODE> - owner of the relation
<DT><B>Returns:</B><DD>object representing empty relation (relation with specified owner and no members), 
 new members can be added to the link later.</DL>
</DD>
</DL>
<HR>

<A NAME="createScalableList()"><!-- --></A><H3>
createScalableList</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt; <B>createScalableList</B>()</PRE>
<DL>
<DD>Create new scalable list of persistent objects.
 This container can efficiently handle small lists as well as large lists
 When number of members is small, Link class is used to store set members. 
 When number of members exceeds some threshold, PersistentList (based on B-Tree)
 is used instead.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>scalable set implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createScalableList(int)"><!-- --></A><H3>
createScalableList</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentList.html" title="interface in org.garret.perst">IPersistentList</A>&lt;T&gt; <B>createScalableList</B>(int&nbsp;initialSize)</PRE>
<DL>
<DD>Create new scalable list of persistent objects.
 This container can efficiently handle small lists as well as large lists
 When number of members is small, Link class is used to store set members. 
 When number of members exceeds some threshold, PersistentList (based on B-Tree)
 is used instead.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialSize</CODE> - initial allocated size of the list
<DT><B>Returns:</B><DD>scalable set implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createScalableSet()"><!-- --></A><H3>
createScalableSet</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt; <B>createScalableSet</B>()</PRE>
<DL>
<DD>Create new scalable set references to persistent objects.
 This container can efficiently store small number of references as well as very large
 number references. When number of members is small, Link class is used to store 
 set members. When number of members exceeds some threshold, PersistentSet (based on B-Tree)
 is used instead.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>scalable set implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createScalableSet(int)"><!-- --></A><H3>
createScalableSet</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt; <B>createScalableSet</B>(int&nbsp;initialSize)</PRE>
<DL>
<DD>Create new scalable set references to persistent objects.
 This container can efficiently store small number of references as well as very large
 number references. When number of members is small, Link class is used to store 
 set members. When number of members exceeds some threshold, PersistentSet (based on B-Tree)
 is used instead.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialSize</CODE> - initial size of the set
<DT><B>Returns:</B><DD>scalable set implementation</DL>
</DD>
</DL>
<HR>

<A NAME="createSet()"><!-- --></A><H3>
createSet</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/IPersistentSet.html" title="interface in org.garret.perst">IPersistentSet</A>&lt;T&gt; <B>createSet</B>()</PRE>
<DL>
<DD>Create new peristent set. Implementation of this set is based on B-Tree so it can efficiently
 handle large number of objects but in case of very small set memory overhead is too high.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing set</DL>
</DD>
</DL>
<HR>

<A NAME="createSortedCollection(org.garret.perst.PersistentComparator, boolean)"><!-- --></A><H3>
createSortedCollection</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/SortedCollection.html" title="interface in org.garret.perst">SortedCollection</A>&lt;T&gt; <B>createSortedCollection</B>(<A HREF="../../../org/garret/perst/PersistentComparator.html" title="class in org.garret.perst">PersistentComparator</A>&lt;T&gt;&nbsp;comparator,
                                               boolean&nbsp;unique)</PRE>
<DL>
<DD>Create new sorted collection
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>comparator</CODE> - comparator class specifying order in the collection<DD><CODE>unique</CODE> - whether index is collection (members with the same key value are not allowed)
<DT><B>Returns:</B><DD>persistent object implementing sorted collection</DL>
</DD>
</DL>
<HR>

<A NAME="createSpatialIndex()"><!-- --></A><H3>
createSpatialIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/SpatialIndex.html" title="interface in org.garret.perst">SpatialIndex</A>&lt;T&gt; <B>createSpatialIndex</B>()</PRE>
<DL>
<DD>Create new spatial index with integer coordinates
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing spatial index</DL>
</DD>
</DL>
<HR>

<A NAME="createSpatialIndexR2()"><!-- --></A><H3>
createSpatialIndexR2</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/SpatialIndexR2.html" title="interface in org.garret.perst">SpatialIndexR2</A>&lt;T&gt; <B>createSpatialIndexR2</B>()</PRE>
<DL>
<DD>Create new R2 spatial index
<P>
<DD><DL>

<DT><B>Returns:</B><DD>persistent object implementing spatial index</DL>
</DD>
</DL>
<HR>

<A NAME="createThickIndex(java.lang.Class)"><!-- --></A><H3>
createThickIndex</H3>
<PRE>
&lt;T&gt; <A HREF="../../../org/garret/perst/Index.html" title="interface in org.garret.perst">Index</A>&lt;T&gt; <B>createThickIndex</B>(java.lang.Class&nbsp;type)</PRE>
<DL>
<DD>Create new think index (index with large number of duplicated keys)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - type of the index key (you should path here <code>String.class</code>, 
 <code>int.class</code>, ...)
<DT><B>Returns:</B><DD>persistent object implementing index
<DT><B>Throws:</B>
<DD><CODE>StorageError(StorageError.UNSUPPORTED_INDEX_TYPE)</CODE> - exception if 
 specified key type is not supported by implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="createTimeSeries(java.lang.Class, long)"><!-- --></A><H3>
createTimeSeries</H3>
<PRE>
&lt;T extends <A HREF="../../../org/garret/perst/TimeSeries.Tick.html" title="interface in org.garret.perst">TimeSeries.Tick</A>&gt; <A HREF="../../../org/garret/perst/TimeSeries.html" title="interface in org.garret.perst">TimeSeries</A>&lt;T&gt; <B>createTimeSeries</B>(java.lang.Class&nbsp;blockClass,
                                                           long&nbsp;maxBlockTimeInterval)</PRE>
<DL>
<DD>Create new time series object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blockClass</CODE> - class derived from TimeSeries.Block<DD><CODE>maxBlockTimeInterval</CODE> - maximal difference in milliseconds between timestamps 
 of the first and the last elements in a block. 
 If value of this parameter is too small, then most blocks will contains less elements 
 than preallocated. 
 If it is too large, then searching of block will be inefficient, because index search 
 will select a lot of extra blocks which do not contain any element from the 
 specified range.
 Usually the value of this parameter should be set as
 (number of elements in block)*(tick interval)*2. 
 Coefficient 2 here is used to compencate possible holes in time series.
 For example, if we collect stocks data, we will have data only for working hours.
 If number of element in block is 100, time series period is 1 day, then
 value of maxBlockTimeInterval can be set as 100*(24*60*60*1000)*2
<DT><B>Returns:</B><DD>new empty time series</DL>
</DD>
</DL>
<HR>

<A NAME="deallocate(java.lang.Object)"><!-- --></A><H3>
deallocate</H3>
<PRE>
void <B>deallocate</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Deallocaste object
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - deallocated object</DL>
</DD>
</DL>
<HR>

<A NAME="deallocateObject(java.lang.Object)"><!-- --></A><H3>
deallocateObject</H3>
<PRE>
void <B>deallocateObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="endThreadTransaction()"><!-- --></A><H3>
endThreadTransaction</H3>
<PRE>
void <B>endThreadTransaction</B>()</PRE>
<DL>
<DD>End per-thread transaction started by beginThreadTransaction method.<br>
 If transaction is <i>exclusive</i>, this method commits the transaction and
 allows other thread to proceed.<br>
 If transaction is <i>serializable</i>, this method commits sll changes done by this thread
 and release all locks set by this thread.<br>     
 If transaction is <i>cooperative</i>, this method decrement counter of cooperative
 transactions and if it becomes zero - commit the work
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="endThreadTransaction(int)"><!-- --></A><H3>
endThreadTransaction</H3>
<PRE>
void <B>endThreadTransaction</B>(int&nbsp;maxDelay)</PRE>
<DL>
<DD>End per-thread cooperative transaction with specified maximal delay of transaction
 commit. When cooperative transaction is ended, data is not immediately committed to the
 disk (because other cooperative transaction can be active at this moment of time).
 Instead of it cooperative transaction counter is decremented. Commit is performed
 only when this counter reaches zero value. But in case of heavy load there can be a lot of
 requests and so a lot of active cooperative transactions. So transaction counter never reaches zero value.
 If system crash happens a large amount of work will be lost in this case. 
 To prevent such scenario, it is possible to specify maximal delay of pending transaction commit.
 In this case when such timeout is expired, new cooperative transaction will be blocked until
 transaction is committed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxDelay</CODE> - maximal delay in milliseconds of committing transaction.  Please notice, that Perst could 
 not force other threads to commit their cooperative transactions when this timeout is expired. It will only
 block new cooperative transactions to make it possible to current transaction to complete their work.
 If <code>maxDelay</code> is 0, current thread will be blocked until all other cooperative trasnaction are also finished
 and changhes will be committed to the database.</DL>
</DD>
</DL>
<HR>

<A NAME="exportXML(java.io.Writer)"><!-- --></A><H3>
exportXML</H3>
<PRE>
void <B>exportXML</B>(java.io.Writer&nbsp;writer)
               throws java.io.IOException</PRE>
<DL>
<DD>Export database in XML format
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>writer</CODE> - writer for generated XML document
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="findClassLoader(java.lang.String)"><!-- --></A><H3>
findClassLoader</H3>
<PRE>
java.lang.ClassLoader <B>findClassLoader</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Find registered class loaders by name
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - class loader name
<DT><B>Returns:</B><DD>class loader with such name or numm if no class loader is found</DL>
</DD>
</DL>
<HR>

<A NAME="gc()"><!-- --></A><H3>
gc</H3>
<PRE>
int <B>gc</B>()</PRE>
<DL>
<DD>Explicit start of garbage collector
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of collected (deallocated) objects</DL>
</DD>
</DL>
<HR>

<A NAME="getClassLoader()"><!-- --></A><H3>
getClassLoader</H3>
<PRE>
java.lang.ClassLoader <B>getClassLoader</B>()</PRE>
<DL>
<DD>Get class loader used to locate classes for 
 loaded class descriptors.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>class loader previously set by <code>setClassLoader</code>
 method or <code>null</code> if not specified.</DL>
</DD>
</DL>
<HR>

<A NAME="getDatabaseFormatVersion()"><!-- --></A><H3>
getDatabaseFormatVersion</H3>
<PRE>
int <B>getDatabaseFormatVersion</B>()</PRE>
<DL>
<DD>Get version of database format for this database. When new database is created it is
 always assigned the current database format version
<P>
<DD><DL>

<DT><B>Returns:</B><DD>databasse format version</DL>
</DD>
</DL>
<HR>

<A NAME="getDatabaseSize()"><!-- --></A><H3>
getDatabaseSize</H3>
<PRE>
long <B>getDatabaseSize</B>()</PRE>
<DL>
<DD>Get size of the database
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getListener()"><!-- --></A><H3>
getListener</H3>
<PRE>
<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A> <B>getListener</B>()</PRE>
<DL>
<DD>Get storage listener.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current storage listener</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryDump()"><!-- --></A><H3>
getMemoryDump</H3>
<PRE>
java.util.HashMap&lt;java.lang.Class,<A HREF="../../../org/garret/perst/MemoryUsage.html" title="class in org.garret.perst">MemoryUsage</A>&gt; <B>getMemoryDump</B>()</PRE>
<DL>
<DD>Get database memory dump. This function returns hashmap which key is classes
 of stored objects and value - MemoryUsage object which specifies number of instances
 of particular class in the storage and total size of memory used by these instance.
 Size of internal database structures (object index,* memory allocation bitmap) is associated with 
 <code>Storage</code> class. Size of class descriptors  - with <code>java.lang.Class</code> class.
 <p>This method traverse the storage as garbage collection do - starting from the root object
 and recursively visiting all reachable objects. So it reports statistic only for visible objects.
 If total database size is significantly larger than total size of all instances reported
 by this method, it means that there is garbage in the database. You can explicitly invoke
 garbage collector in this case.</p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectByOID(int)"><!-- --></A><H3>
getObjectByOID</H3>
<PRE>
java.lang.Object <B>getObjectByOID</B>(int&nbsp;oid)</PRE>
<DL>
<DD>Retrieve object by OID. This method should be used with care because
 if object is deallocated, its OID can be reused. In this case
 getObjectByOID will return reference to the new object with may be
 different type.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oid</CODE> - object oid
<DT><B>Returns:</B><DD>reference to the object with specified OID</DL>
</DD>
</DL>
<HR>

<A NAME="getOid(java.lang.Object)"><!-- --></A><H3>
getOid</H3>
<PRE>
int <B>getOid</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Get object identifier
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - inspected object</DL>
</DD>
</DL>
<HR>

<A NAME="getProperties()"><!-- --></A><H3>
getProperties</H3>
<PRE>
java.util.Properties <B>getProperties</B>()</PRE>
<DL>
<DD>Get all set properties
<P>
<DD><DL>

<DT><B>Returns:</B><DD>all properties set by setProperty or setProperties method</DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String)"><!-- --></A><H3>
getProperty</H3>
<PRE>
java.lang.Object <B>getProperty</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Get property value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - property name
<DT><B>Returns:</B><DD>value of the property previously assigned by setProperty or setProperties method
 or <code>null</code> if property was not set</DL>
</DD>
</DL>
<HR>

<A NAME="getRoot()"><!-- --></A><H3>
getRoot</H3>
<PRE>
java.lang.Object <B>getRoot</B>()</PRE>
<DL>
<DD>Get storage root. Storage can have exactly one root object. 
 If you need to have several root object and access them by name (as is is possible 
 in many other OODBMSes), you should create index and use it as root object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>root object or <code>null</code> if root is not specified (storage is not yet initialized)</DL>
</DD>
</DL>
<HR>

<A NAME="getSqlOptimizerParameters()"><!-- --></A><H3>
getSqlOptimizerParameters</H3>
<PRE>
<A HREF="../../../org/garret/perst/SqlOptimizerParameters.html" title="class in org.garret.perst">SqlOptimizerParameters</A> <B>getSqlOptimizerParameters</B>()</PRE>
<DL>
<DD>Get SQL optimizer parameters.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current SQL optimizer parameters. It is possible to tune these parameters by updating fields 
 of this object.</DL>
</DD>
</DL>
<HR>

<A NAME="getTransactionContext()"><!-- --></A><H3>
getTransactionContext</H3>
<PRE>
org.garret.perst.impl.ThreadTransactionContext <B>getTransactionContext</B>()</PRE>
<DL>
<DD>This method is used internally by Perst to get transaction context associated with current thread.
 But it can be also used by application to get transaction context, store it in some variable and
 use in another thread. I will make it possible to share one transaction between multiple threads.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>transaction context associated with current thread</DL>
</DD>
</DL>
<HR>

<A NAME="getUsedSize()"><!-- --></A><H3>
getUsedSize</H3>
<PRE>
long <B>getUsedSize</B>()</PRE>
<DL>
<DD>Get total size of all allocated objects in the database
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="importXML(java.io.Reader)"><!-- --></A><H3>
importXML</H3>
<PRE>
void <B>importXML</B>(java.io.Reader&nbsp;reader)
               throws <A HREF="../../../org/garret/perst/XMLImportException.html" title="class in org.garret.perst">XMLImportException</A></PRE>
<DL>
<DD>Import data from XML file
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reader</CODE> - XML document reader
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/garret/perst/XMLImportException.html" title="class in org.garret.perst">XMLImportException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isInsideThreadTransaction()"><!-- --></A><H3>
isInsideThreadTransaction</H3>
<PRE>
boolean <B>isInsideThreadTransaction</B>()</PRE>
<DL>
<DD>Check if nested thread transaction is active
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if code executing this method is inside per-thread transaction 
 (serializable, exclusive or coopertaive)</DL>
</DD>
</DL>
<HR>

<A NAME="isOpened()"><!-- --></A><H3>
isOpened</H3>
<PRE>
boolean <B>isOpened</B>()</PRE>
<DL>
<DD>Check if database is opened
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if database was opened by <code>open</code> method, 
 <code>false</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="join(java.util.Iterator[])"><!-- --></A><H3>
join</H3>
<PRE>
java.util.Iterator <B>join</B>(java.util.Iterator[]&nbsp;selections)</PRE>
<DL>
<DD>Join results of several index searches. This method efficiently join selections without loading objects themselve
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>selections</CODE> - selections to be merged
<DT><B>Returns:</B><DD>Iterator through joineded result</DL>
</DD>
</DL>
<HR>

<A NAME="load(java.lang.Object)"><!-- --></A><H3>
load</H3>
<PRE>
void <B>load</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Load raw object
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - loaded object</DL>
</DD>
</DL>
<HR>

<A NAME="loadObject(java.lang.Object)"><!-- --></A><H3>
loadObject</H3>
<PRE>
void <B>loadObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockObject(java.lang.Object)"><!-- --></A><H3>
lockObject</H3>
<PRE>
boolean <B>lockObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makePersistent(java.lang.Object)"><!-- --></A><H3>
makePersistent</H3>
<PRE>
int <B>makePersistent</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Explicitely make object peristent. Usually objects are made persistent
 implicitlely using "persistency on reachability apporach", but this
 method allows to do it explicitly. If object is already persistent, execution of
 this method has no effect.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - object to be made persistent
<DT><B>Returns:</B><DD>OID assigned to the object</DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.util.Iterator[])"><!-- --></A><H3>
merge</H3>
<PRE>
java.util.Iterator <B>merge</B>(java.util.Iterator[]&nbsp;selections)</PRE>
<DL>
<DD>Merge results of several index searches. This method efficiently merge selections without loading objects themselve
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>selections</CODE> - selections to be merged
<DT><B>Returns:</B><DD>Iterator through merged result</DL>
</DD>
</DL>
<HR>

<A NAME="modify(java.lang.Object)"><!-- --></A><H3>
modify</H3>
<PRE>
void <B>modify</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Mark object as been modified
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - modified object</DL>
</DD>
</DL>
<HR>

<A NAME="modifyObject(java.lang.Object)"><!-- --></A><H3>
modifyObject</H3>
<PRE>
void <B>modifyObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="open(org.garret.perst.IFile)"><!-- --></A><H3>
open</H3>
<PRE>
void <B>open</B>(<A HREF="../../../org/garret/perst/IFile.html" title="interface in org.garret.perst">IFile</A>&nbsp;file)</PRE>
<DL>
<DD>Open the storage with default page pool size
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>file</CODE> - user specific implementation of IFile interface</DL>
</DD>
</DL>
<HR>

<A NAME="open(org.garret.perst.IFile, long)"><!-- --></A><H3>
open</H3>
<PRE>
void <B>open</B>(<A HREF="../../../org/garret/perst/IFile.html" title="interface in org.garret.perst">IFile</A>&nbsp;file,
          long&nbsp;pagePoolSize)</PRE>
<DL>
<DD>Open the storage
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>file</CODE> - user specific implementation of IFile interface<DD><CODE>pagePoolSize</CODE> - size of page pool (in bytes). Page pool should contain
 at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
 But larger page pool ussually leads to better performance (unless it could not fit
 in memory and cause swapping).</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String)"><!-- --></A><H3>
open</H3>
<PRE>
void <B>open</B>(java.lang.String&nbsp;filePath)</PRE>
<DL>
<DD>Open the storage with default page pool size
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filePath</CODE> - path to the database file</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String, long)"><!-- --></A><H3>
open</H3>
<PRE>
void <B>open</B>(java.lang.String&nbsp;filePath,
          long&nbsp;pagePoolSize)</PRE>
<DL>
<DD>Open the storage
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filePath</CODE> - path to the database file<DD><CODE>pagePoolSize</CODE> - size of page pool (in bytes). Page pool should contain
 at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
 But larger page pool usually leads to better performance (unless it could not fit
 in memory and cause swapping). Value 0 of this paremeter corresponds to infinite
 page pool (all pages are cashed in memory). It is especially useful for in-memory
 database, when storage is created with NullFile.</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String, long, java.lang.String)"><!-- --></A><H3>
open</H3>
<PRE>
void <B>open</B>(java.lang.String&nbsp;filePath,
          long&nbsp;pagePoolSize,
          java.lang.String&nbsp;cipherKey)</PRE>
<DL>
<DD>Open the encrypted storage
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>filePath</CODE> - path to the database file<DD><CODE>pagePoolSize</CODE> - size of page pool (in bytes). Page pool should contain
 at least then 4kb pages, so minimal page pool size should be at least 40Kb.
 But larger page pool usually leads to better performance (unless it could not fit
 in memory and cause swapping).<DD><CODE>cipherKey</CODE> - cipher key</DL>
</DD>
</DL>
<HR>

<A NAME="registerClassLoader(org.garret.perst.INamedClassLoader)"><!-- --></A><H3>
registerClassLoader</H3>
<PRE>
void <B>registerClassLoader</B>(<A HREF="../../../org/garret/perst/INamedClassLoader.html" title="interface in org.garret.perst">INamedClassLoader</A>&nbsp;loader)</PRE>
<DL>
<DD>Register named class loader in the storage. Mechanism of named class loaders
 allows to store in database association between class and its class loader.
 All named class loaders should be registered before database open.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>loader</CODE> - registered named class loader</DL>
</DD>
</DL>
<HR>

<A NAME="registerCustomAllocator(java.lang.Class, org.garret.perst.CustomAllocator)"><!-- --></A><H3>
registerCustomAllocator</H3>
<PRE>
void <B>registerCustomAllocator</B>(java.lang.Class&nbsp;cls,
                             <A HREF="../../../org/garret/perst/CustomAllocator.html" title="interface in org.garret.perst">CustomAllocator</A>&nbsp;allocator)</PRE>
<DL>
<DD>Register custom allocator for specified class. Instances of this and derived classes 
 will be allocated in the storage using specified allocator.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cls</CODE> - class of the persistent object which instances will be allocated using this allocator<DD><CODE>allocator</CODE> - custom allocator</DL>
</DD>
</DL>
<HR>

<A NAME="rollback()"><!-- --></A><H3>
rollback</H3>
<PRE>
void <B>rollback</B>()</PRE>
<DL>
<DD>Rollback changes made by the last transaction.
 By default, Perst doesn't reload modified objects after a transaction
 rollback. In this case, the programmer should not use references to the
 persistent objects stored in program variables. Instead, the application
 should fetch the object tree from the beginning, starting from obtaining the
 root object using the Storage.getRoot method.
 Setting the "perst.reload.objects.on.rollback" property instructs Perst to
 reload all objects modified by the aborted (rolled back) transaction. It
 takes additional processing time, but in this case it is not necessary to
 ignore references stored in variables, unless they point to the objects
 created by this transactions (which were invalidated when the transaction
 was rolled back). Unfortunately, there is no way to prohibit access to such
 objects or somehow invalidate references to them. So this option should be
 used with care.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rollbackSerializableTransaction()"><!-- --></A><H3>
rollbackSerializableTransaction</H3>
<PRE>
void <B>rollbackSerializableTransaction</B>()</PRE>
<DL>
<DD>Rollback serializable transaction. This call is equivalent to <code>rollbackThreadTransaction</code>
 but it checks that serializable transaction was pereviously started using 
 beginSerializableTransaction() method
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>StorageError(NOT_IN_TRANSACTION)</CODE> - if this method is invoked outside 
 serializable transaction body</DL>
</DD>
</DL>
<HR>

<A NAME="rollbackThreadTransaction()"><!-- --></A><H3>
rollbackThreadTransaction</H3>
<PRE>
void <B>rollbackThreadTransaction</B>()</PRE>
<DL>
<DD>Rollback per-thread transaction. It is safe to use this method only for exclusive transactions.
 In case of cooperative transactions, this method rollback results of all transactions.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClassLoader(java.lang.ClassLoader)"><!-- --></A><H3>
setClassLoader</H3>
<PRE>
java.lang.ClassLoader <B>setClassLoader</B>(java.lang.ClassLoader&nbsp;loader)</PRE>
<DL>
<DD>Set class loader. This class loader will be used to locate classes for 
 loaded class descriptors. If class loader is not specified or
 it did find the class, then <code>Class.forName()</code> method
 will be used to get class for the specified name.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>loader</CODE> - class loader
<DT><B>Returns:</B><DD>previous class loader or null if not specified</DL>
</DD>
</DL>
<HR>

<A NAME="setCustomSerializer(org.garret.perst.CustomSerializer)"><!-- --></A><H3>
setCustomSerializer</H3>
<PRE>
void <B>setCustomSerializer</B>(<A HREF="../../../org/garret/perst/CustomSerializer.html" title="interface in org.garret.perst">CustomSerializer</A>&nbsp;serializer)</PRE>
<DL>
<DD>Set custom serializer used fot packing/unpacking fields of persistent objects which types implemplemet 
 CustomSerializable interface
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setGcThreshold(long)"><!-- --></A><H3>
setGcThreshold</H3>
<PRE>
void <B>setGcThreshold</B>(long&nbsp;allocatedDelta)</PRE>
<DL>
<DD>Set threshold for initiation of garbage collection. By default garbage collection is disable (threshold is set to
 Long.MAX_VALUE). If it is set to the value different from Long.MAX_VALUE, GC will be started each time when
 delta between total size of allocated and deallocated objects exceeds specified threashold OR
 after reaching end of allocation bitmap in allocator.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>allocatedDelta</CODE> - delta between total size of allocated and deallocated object since last GC 
 or storage opening</DL>
</DD>
</DL>
<HR>

<A NAME="setListener(org.garret.perst.StorageListener)"><!-- --></A><H3>
setListener</H3>
<PRE>
<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A> <B>setListener</B>(<A HREF="../../../org/garret/perst/StorageListener.html" title="class in org.garret.perst">StorageListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Set storage listener.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - new storage listener (may be null)
<DT><B>Returns:</B><DD>previous storage listener</DL>
</DD>
</DL>
<HR>

<A NAME="setProperties(java.util.Properties)"><!-- --></A><H3>
setProperties</H3>
<PRE>
void <B>setProperties</B>(java.util.Properties&nbsp;props)</PRE>
<DL>
<DD>Set database properties. This method should be invoked before opening database. 
 For list of supported properties please see <code>setProperty</code> command. 
 All not recognized properties are ignored.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setProperty(java.lang.String, java.lang.Object)"><!-- --></A><H3>
setProperty</H3>
<PRE>
void <B>setProperty</B>(java.lang.String&nbsp;name,
                 java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Set database property. This method should be invoked before opening database. 
 Currently the following boolean properties are supported:
 <TABLE><TR><TH>Property name</TH><TH>Parameter type</TH><TH>Default value</TH><TH>Description</TH></TR>
 <TR><TD><code>perst.implicit.values</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Treate any class not derived from IPersistent as <i>value</i>. 
 This object will be embedded inside persistent object containing reference to this object.
 If this object is referenced from N persistent object, N instances of this object
 will be stored in the database and after loading there will be N instances in memory. 
 As well as persistent capable classes, value classes should have default constructor (constructor
 with empty list of parameters) or has no constructors at all. For example <code>Integer</code>
 class can not be stored as value in PERST because it has no such constructor. In this case 
 serialization mechanism can be used (see below)
 </TD></TR>
 <TR><TD><code>perst.serialize.transient.objects</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Serialize any class not derived from IPersistent or IValue using standard Java serialization
 mechanism. Packed object closure is stored in database as byte array. Latter the same mechanism is used
 to unpack the objects. To be able to use this mechanism object and all objects referenced from it
 should implement <code>java.io.Serializable</code> interface and should not contain references
 to persistent objects. If such object is referenced from N persistent object, N instances of this object
 will be stored in the database and after loading there will be N instances in memory.
 </TD></TR>
 <TR><TD><code>perst.object.cache.init.size</code></TD><TD>Integer</TD><TD>1319</TD>
 <TD>Initial size of object cache
 </TD></TR>
 <TR><TD><code>perst.object.cache.kind</code></TD><TD>String</TD><TD>"lru"</TD>
 <TD>Kind of object cache. The following values are supported:
 "strong", "weak", "soft",  "pinned", "lru". <B>Strong</B> cache uses strong (normal) 
 references to refer persistent objects. Thus none of loaded persistent objects
 can be deallocated by GC. <B>Weak</B> cache usea weak references and
 soft cache - <B>soft</B> references. The main difference between soft and weak references is
 that garbage collector is not required to remove soft referenced objects immediately
 when object is detected to be <i>soft referenced</i>, so it may improve caching of objects. 
 But it also may increase amount of memory
 used  by application, and as far as persistent object requires finalization
 it can cause memory overflow even though garbage collector is required
 to clear all soft references before throwing OutOfMemoryException.<br>
 But Java specification says nothing about the policy used by GC for soft references
 (except the rule mentioned above). Unlike it <B>lru</B> cache provide determined behavior, 
 pinning most recently used objects in memory. Number of pinned objects is determined 
 for lru cache by <code>perst.object.index.init.size</code> parameter (it can be 0).<br>
 Pinned object cache pin in memory all modified objects while using weak referenced for 
 non-modified objects. This kind of cache eliminate need in finalization mechanism - all modified
 objects are kept in memory and are flushed to the disk only at the end of transaction. 
 So the size of transaction is limited by amount of main memory. Non-modified objects are accessed only 
 through weak references so them are not protected from GC and can be thrown away.    
 </TD></TR>
 <TR><TD><code>perst.object.index.init.size</code></TD><TD>Integer</TD><TD>1024</TD>
 <TD>Initial size of object index (specifying large value increase initial size of database, but reduce
 number of index reallocations)
 </TD></TR>
 <TR><TD><code>perst.extension.quantum</code></TD><TD>Long</TD><TD>1048576</TD>
 <TD>Object allocation bitmap extension quantum. Memory is allocate by scanning bitmap. If there is no
 large enough hole, then database is extended by the value of dbDefaultExtensionQuantum. 
 This parameter should not be smaller than 64Kb.
 </TD></TR>
 <TR><TD><code>perst.gc.threshold</code></TD><TD>Long</TD><TD>Long.MAX_VALUE</TD>
 <TD>Threshold for initiation of garbage collection. 
 If it is set to the value different from Long.MAX_VALUE, GC will be started each time 
 when delta between total size of allocated and deallocated objects exceeds specified threashold OR
 after reaching end of allocation bitmap in allocator.
 </TD></TR>
 <TR><TD><code>perst.lock.file</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Lock database file to prevent concurrent access to the database by 
 more than one application.
 </TD></TR>
 <TR><TD><code>perst.file.readonly</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Database file should be opened in read-only mode.
 </TD></TR>
 <TR><TD><code>perst.file.noflush</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Do not flush file during transaction commit. It will greatly increase performance because
 eliminate synchronous write to the disk (when program has to wait until all changed
 are actually written to the disk). But it can cause database corruption in case of 
 OS or power failure (but abnormal termination of application itself should not cause
 the problem, because all data which were written to the file, but is not yet saved to the disk is 
 stored in OS file buffers and sooner or later them will be written to the disk)
 </TD></TR>
 <TR><TD><code>perst.alternative.btree</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Use aternative implementation of B-Tree (not using direct access to database
 file pages). This implementation should be used in case of serialized per thread transctions.
 New implementation of B-Tree will be used instead of old implementation
 if "perst.alternative.btree" property is set. New B-Tree has incompatible format with 
 old B-Tree, so you could not use old database or XML export file with new indices. 
 Alternative B-Tree is needed to provide serializable transaction (old one could not be used).
 Also it provides better performance (about 3 times comaring with old implementation) because
 of object caching. And B-Tree supports keys of user defined types. 
 </TD></TR>
 <TR><TD><code>perst.background.gc</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Perform garbage collection in separate thread without blocking the main application.
 </TD></TR>
 <TR><TD><code>perst.string.encoding</code></TD><TD>String</TD><TD>null</TD>
 <TD>Specifies encoding of storing strings in the database. By default Perst stores 
 strings as sequence of chars (two bytes per char). If all strings in application are in 
 the same language, then using encoding  can signifficantly reduce space needed
 to store string (about two times). But please notice, that this option has influence
 on all strings  stored in database. So if you already have some data in the storage
 and then change encoding, then it will cause database crash.
 </TD></TR>
 <TR><TD><code>perst.replication.ack</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Request acknowledgement from slave that it receives all data before transaction
 commit. If this option is not set, then replication master node just writes
 data to the socket not warring whether it reaches slave node or not.
 When this option is set to true, master not will wait during each transaction commit acknowledgement
 from slave node. Please notice that this option should be either set or not set both
 at slave and master node. If it is set only on one of this nodes then behavior of
 the system is unpredicted. This option can be used both in synchronous and asynchronous replication
 mode. The only difference is that in first case main application thread will be blocked waiting
 for acknowledgment, while in the asynchronous mode special replication thread will be blocked
 allowing thread performing commit to proceed.
 </TD></TR>
 <TR><TD><code>perst.concurrent.iterator</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>By default iterator will throw ConcurrentModificationException if iterated collection
 was changed outside iterator, when the value of this property is true then iterator will 
 try to restore current position and continue iteration
 </TD></TR>
 <TR><TD><code>perst.slave.connection.timeout</code></TD><TD>Integer</TD><TD>60</TD>
 <TD>Timeout in seconds during which mastr node will try to establish connection with slave node. 
 If connection can not be established within specified time, then master will not perform 
 replication to this slave node
 </TD></TR>
 <TR><TD><code>perst.force.store</code></TD><TD>Boolean</TD><TD>true</TD>
 <TD>When the value of this parameter is true Storage.makePersistent method
 cause immediate storing of object in the storage, otherwise object is assigned OID and is marked 
 as modified. Storage.makePersistent method is mostly used when object is inserted in B-Tree.
 If application put in index object referencing a large number of other objects which also has to 
 be made persistent, then marking object as modified instead of immediate storing may cause
 memory overflow because garbage collector and finalization threads will store objects
 with less speed than application creates new ones.
 But if object will be updated after been placed in B-Tree, then immediate store will just cause
 cause extra overhead, because object has to be stored twice. 
 </TD></TR>
 <TR><TD><code>perst.page.pool.lru.limit</code></TD><TD>Long</TD><TD>1L << 60</TD>
 <TD>Set boundary for caching database pages in page pool. 
 By default Perst is using LRU algorithm for finding candidate for replacement.
 But for example for BLOBs this strategy is not optimal and fetching BLOB can
 cause flushing the whole page pool if LRU discipline is used. And with high
 probability fetched BLOB pages will no be used any more. So it is preferable not
 to cache BLOB pages at all (throw away such page immediately when it is not used any more).
 This parameter in conjunction with custom allocator allows to disable caching
 for BLOB objects. If you set value of "perst.page.lru.scope" property equal
 to base address of custom allocator (which will be used to allocate BLOBs), 
 then page containing objects allocated by this allocator will not be cached in page pool.
 </TD></TR>
 <TR><TD><code>perst.multiclient.support</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>Supports access to the same database file by multiple applications.
 In this case Perst will use file locking to synchronize access to the database file.
 An application MUST wrap any access to the database with  beginThreadThreansaction/endThreadTransaction 
 methods. For read only access use READ_ONLY_TRANSACTION mode and if transaction may modify database then
 READ_WRITE_TRANSACTION mode should be used.
 </TD></TR>
 <TR><TD><code>perst.reload.objects.on.rollback</code></TD><TD>Boolean</TD><TD>false</TD>
 <TD>By default, Perst doesn't reload modified objects after a transaction
 rollback. In this case, the programmer should not use references to the
 persistent objects stored in program variables. Instead, the application
 should fetch the object tree from the beginning, starting from obtaining the
 root object using the Storage.getRoot method.

 Setting the "perst.reload.objects.on.rollback" property instructs Perst to
 reload all objects modified by the aborted (rolled back) transaction. It
 takes additional processing time, but in this case it is not necessary to
 ignore references stored in variables, unless they point to the objects
 created by this transactions (which were invalidated when the transaction
 was rolled back). Unfortunately, there is no way to prohibit access to such
 objects or somehow invalidate references to them. So this option should be
 used with care.
 </TD></TR>
 <TR><TD><code>perst.reuse.oid</code></TD><TD>bool</TD><TD>true</TD>
 <TD>This parameters allows to disable reusing OID of deallocated objects.
 It can simplify debugging of application performing explicit deallocation of objects
 (not using garbage collection). Explicit object deallocation can cause "dangling references"
 problem - when there are live references to the deallocated object.
 Access to such object should cause <code>StorageError(DELETED_OBJECT)</code> exception.
 But if OID of the object can be reused and assigned to some newly deallocated object, 
 then we will get type cast or field access errors when try to work with this object.
 In the worst case OID will be reused by the object of the same type - then application
 will not notice that referenced object was substituted.
 Disabling reuse of OID allows to eliminate such unpredictable behavior - 
 access to the deallocated object will always cause <code>StorageError(DELETED_OBJECT)</code> exception. 
 But please notice that disabling reuse of OID for a long time and intensive allocation/deallocation
 of objects can cause exhaustion of OID space (2Gb).
 </TD></TR>
 <TR><TD><code>perst.compatibilit.mode</code></TD><TD>int</TD><TD>0</TD>
 <TD>Bitmask of different compatibility modes. Right now the following modes are supported:
 IBM_JAVA5_COMPATIBILITY_MODE: compatibility with databases created by Perst prior to 2.73 release by IBM Java5 VM
 CLASS_LOADER_SERIALIZATION_COMPATIBILITY_MODE: compatibility with databases created by Perst prior to 2.66 and
 using custom class loaders and serialization of transient objects
 </TD></TR>
 <TR><TD><code>perst.global.class.extent</code></TD><TD>bool</TD><TD>true</TD>
 <TD>This parameter is used by Database class in "auto register table" mode. 
 In this mode Perst automatically creates indices (class extents) for all derived classes of the inserted object 
 if there are no such class extents yet. It include class extent for Perstistent class allowing to enumerate all
 objects in the storage. If such list is not needed, then this option can be set to false to 
 eliminate extra index maintenance overhead.
 </TD></TR>
 <TR><TD><code>perst.search.base.classes</code></TD><TD>bool</TD><TD>true</TD>
 <TD>This parameter is used by Database class. If there is no table (class extent) corresponding
 to the requested class, then Perst tries to locate class extend for base class and so on.
 By setting this property to false it is possible to prohibit lookup of base classes.
 Please notice that lookup on base classes is also not performed if "auto register table" mode is active. 
 </TD></TR>
 </TABLE>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - name of the property<DD><CODE>value</CODE> - value of the property (for boolean properties pass <code>java.lang.Boolean.TRUE</code>
 and <code>java.lang.Boolean.FALSE</code></DL>
</DD>
</DL>
<HR>

<A NAME="setRecursiveLoading(java.lang.Class, boolean)"><!-- --></A><H3>
setRecursiveLoading</H3>
<PRE>
boolean <B>setRecursiveLoading</B>(java.lang.Class&nbsp;type,
                            boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enable or disable recursive loading for specified class.
 Recursive loading can be also controlled by overriding recursiveLoading method of
 Persistent class, but if class is not derived from Persistent base class and
 not implementing IPersistent interface, this method can be used to control 
 recursive loading.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - Class for which recursive loading policy is specified.
    By default recursive loading is enabled for all classes. Disabling recursive loading for some
     class also affect all derived classes unless policy is explicitly specified for such class.<DD><CODE>enabled</CODE> - Whether recursive loading is enabled or disabled for this class
<DT><B>Returns:</B><DD>previous status of recursive loading policy for the specified class</DL>
</DD>
</DL>
<HR>

<A NAME="setRoot(java.lang.Object)"><!-- --></A><H3>
setRoot</H3>
<PRE>
void <B>setRoot</B>(java.lang.Object&nbsp;root)</PRE>
<DL>
<DD>Set new storage root object.
 Previous reference to the root object is rewritten but old root is not automatically deallocated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>root</CODE> - object to become new storage root. If it is not persistent yet, it is made
 persistent and stored in the storage</DL>
</DD>
</DL>
<HR>

<A NAME="setTransactionContext(org.garret.perst.impl.ThreadTransactionContext)"><!-- --></A><H3>
setTransactionContext</H3>
<PRE>
org.garret.perst.impl.ThreadTransactionContext <B>setTransactionContext</B>(org.garret.perst.impl.ThreadTransactionContext&nbsp;ctx)</PRE>
<DL>
<DD>Associate transaction context with the thread
 This method can be used by application to share the same transaction between multiple threads
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ctx</CODE> - new transaction context
<DT><B>Returns:</B><DD>transaction context previously associated with this thread</DL>
</DD>
</DL>
<HR>

<A NAME="store(java.lang.Object)"><!-- --></A><H3>
store</H3>
<PRE>
void <B>store</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Store object in storage
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - stored object</DL>
</DD>
</DL>
<HR>

<A NAME="storeFinalizedObject(java.lang.Object)"><!-- --></A><H3>
storeFinalizedObject</H3>
<PRE>
void <B>storeFinalizedObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="storeObject(java.lang.Object)"><!-- --></A><H3>
storeObject</H3>
<PRE>
void <B>storeObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="throwObject(java.lang.Object)"><!-- --></A><H3>
throwObject</H3>
<PRE>
void <B>throwObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/garret/perst/SqlOptimizerParameters.html" title="class in org.garret.perst"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/garret/perst/StorageError.html" title="class in org.garret.perst"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/garret/perst/Storage.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Storage.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
